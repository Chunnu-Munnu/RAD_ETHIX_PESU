from fastapi import FastAPI, File, UploadFile, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import HTMLResponse
from pydantic import BaseModel
from typing import List, Optional
import torch
import torch.nn.functional as F
import torchvision.transforms
import torchxrayvision as xrv
import cv2
import numpy as np
from PIL import Image
import io
import base64
import logging
from typing import Dict, List, Any
import pandas as pd
import skimage
import skimage.io
from datetime import datetime

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Initialize FastAPI app
app = FastAPI(
    title="RAD-ETHIX API",
    description="AI-Powered Ethical X-ray Diagnosis using TorchXRayVision",
    version="2.0.0"
)

# Configure CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "http://localhost:3000", 
        "http://127.0.0.1:3000",
        "http://localhost:8000",
        "http://127.0.0.1:8000",
        "http://localhost:3001",
        "http://127.0.0.1:3001",
        "http://localhost:5173",
        "http://127.0.0.1:5173"
    ],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ==================== AUTH SECTION ====================
# Hardcoded user database
USERS_DB = {
    "PES1UG24CS053": {
        "patient_id": "PES1UG24CS053",
        "name": "Amogh",
        "age": 19,
        "gender": "Male"
    }
}

# Store additional registered users (in-memory for demo)
registered_users = {}

class SignupRequest(BaseModel):
    name: str
    age: int
    gender: str

class LoginRequest(BaseModel):
    patient_id: str

class UserResponse(BaseModel):
    patient_id: str
    name: str
    age: int
    gender: str

@app.post("/auth/signup", response_model=UserResponse)
async def signup(request: SignupRequest):
    """Register a new patient"""
    existing_count = len(USERS_DB) + len(registered_users)
    new_id = f"PES1UG24CS{str(existing_count + 54).zfill(3)}"
    new_user = {
        "patient_id": new_id,
        "name": request.name,
        "age": request.age,
        "gender": request.gender
    }
    registered_users[new_id] = new_user
    return new_user

@app.post("/auth/login", response_model=UserResponse)
async def login(request: LoginRequest):
    """Login with patient ID"""
    patient_id = request.patient_id.upper().strip()
    if patient_id in USERS_DB:
        return USERS_DB[patient_id]
    if patient_id in registered_users:
        return registered_users[patient_id]
    raise HTTPException(status_code=404, detail="Patient ID not found")

@app.get("/auth/verify/{patient_id}", response_model=UserResponse)
async def verify_patient(patient_id: str):
    """Verify if patient ID exists"""
    patient_id = patient_id.upper().strip()
    if patient_id in USERS_DB:
        return USERS_DB[patient_id]
    if patient_id in registered_users:
        return registered_users[patient_id]
    raise HTTPException(status_code=404, detail="Patient ID not found")

# ==================== MEDICAL KNOWLEDGE BASE ====================
MEDICAL_KNOWLEDGE = {
    "Atelectasis": {
        "definition": "Collapse or closure of a lung resulting in reduced or absent gas exchange",
        "xray_findings": ["Increased opacity in affected area", "Volume loss with mediastinal shift", "Elevation of hemidiaphragm"],
        "clinical_significance": "May indicate airway obstruction, post-surgical complication, or mucus plugging",
        "action_steps": ["Assess for underlying cause", "Consider chest physiotherapy", "Evaluate need for bronchoscopy if persistent"],
        "citations": ["Woodring JH, Reed JC. Types and mechanisms of pulmonary atelectasis. J Thorac Imaging. 1996;11(2):92-108"]
    },
    "Cardiomegaly": {
        "definition": "Enlargement of the heart, typically defined as cardiothoracic ratio >0.5 on PA chest X-ray",
        "xray_findings": ["Increased cardiac silhouette width", "Cardiothoracic ratio greater than 50%", "Bilateral cardiac border enlargement"],
        "clinical_significance": "Associated with heart failure, valvular disease, hypertension, or cardiomyopathy",
        "action_steps": ["Perform echocardiography for assessment", "Evaluate for signs of heart failure", "Check BNP/NT-proBNP levels"],
        "citations": ["Danzer CS. The cardiothoracic ratio: An index of cardiac enlargement. Am J Med Sci. 1919;157:513-521"]
    },
    "Consolidation": {
        "definition": "Lung tissue has filled with liquid instead of air, appearing as increased density",
        "xray_findings": ["Homogeneous opacity obscuring vascular markings", "Air bronchograms may be visible", "Lobar or segmental distribution"],
        "clinical_significance": "Most commonly indicates pneumonia, but can represent pulmonary edema or hemorrhage",
        "action_steps": ["Correlate with clinical symptoms", "Consider sputum culture and blood tests", "Initiate appropriate antibiotic therapy if infectious"],
        "citations": ["Hansell DM, et al. Fleischner Society: Glossary of terms for thoracic imaging. Radiology. 2008;246(3):697-722"]
    },
    "Edema": {
        "definition": "Accumulation of fluid in lung interstitium and alveoli",
        "xray_findings": ["Bilateral perihilar opacity", "Kerley B lines", "Pleural effusions", "Vascular redistribution to upper lobes"],
        "clinical_significance": "Indicates heart failure, fluid overload, ARDS, or renal failure",
        "action_steps": ["Administer diuretics if cardiac origin", "Assess volume status", "Monitor oxygen saturation"],
        "citations": ["Ware LB, Matthay MA. Acute pulmonary edema. N Engl J Med. 2005;353(26):2788-2796"]
    },
    "Enlarged Cardiomediastinum": {
        "definition": "Widening of the mediastinal silhouette beyond normal limits",
        "xray_findings": ["Mediastinal width >8 cm on PA view", "Widening of superior mediastinum", "Loss of normal contours"],
        "clinical_significance": "May indicate cardiomegaly, lymphadenopathy, mediastinal mass, or aortic aneurysm",
        "action_steps": ["Obtain CT chest with contrast", "Assess for aortic pathology", "Consider echocardiography"],
        "citations": ["Whitten CR, et al. A diagnostic approach to mediastinal abnormalities. Radiographics. 2007;27(3):657-671"]
    },
    "Fracture": {
        "definition": "Break in continuity of rib or other thoracic bony structures",
        "xray_findings": ["Cortical disruption or step-off", "Displacement of bone fragments", "Associated soft tissue swelling"],
        "clinical_significance": "Trauma-related injury with risk of underlying pulmonary contusion or pneumothorax",
        "action_steps": ["Assess for pneumothorax or hemothorax", "Provide adequate analgesia", "Encourage incentive spirometry"],
        "citations": ["Sirmali M, et al. Analysis of traumatic rib fractures. Eur J Cardiothorac Surg. 2003;24(1):133-138"]
    },
    "Lung Lesion": {
        "definition": "Focal abnormality within lung parenchyma",
        "xray_findings": ["Discrete rounded or irregular opacity", "Well-defined or poorly-defined margins", "Variable size"],
        "clinical_significance": "Differential includes malignancy, infection, benign tumor, or metastasis",
        "action_steps": ["Obtain prior imaging for comparison", "CT chest with contrast", "Consider biopsy or PET scan if malignancy suspected"],
        "citations": ["MacMahon H, et al. Guidelines for Management of Pulmonary Nodules. Radiology. 2017;284(1):228-243"]
    },
    "Lung Opacity": {
        "definition": "Any area of increased density within the lung parenchyma",
        "xray_findings": ["Hazy increased density", "Ground-glass appearance possible", "Variable patterns and distributions"],
        "clinical_significance": "Non-specific finding that may represent infection, inflammation, or interstitial disease",
        "action_steps": ["Clinical correlation with symptoms essential", "Determine acute versus chronic nature", "Consider CT chest if persistent"],
        "citations": ["Hansell DM, et al. Fleischner Society glossary. Radiology. 2008;246(3):697-722"]
    },
    "No Finding": {
        "definition": "Chest radiograph demonstrates normal pulmonary and cardiac structures",
        "xray_findings": ["Clear lung fields bilaterally", "Normal cardiac silhouette", "Sharp costophrenic angles"],
        "clinical_significance": "Normal chest radiograph, though clinical symptoms may still warrant further evaluation",
        "action_steps": ["Correlate with clinical presentation", "CT chest may be warranted if high clinical suspicion", "Routine follow-up"],
        "citations": ["Raoof S, et al. Interpretation of plain chest roentgenogram. Chest. 2012;141(2):545-558"]
    },
    "Pleural Effusion": {
        "definition": "Abnormal collection of fluid in the pleural space",
        "xray_findings": ["Blunting of costophrenic angle", "Meniscus sign", "Homogeneous opacity at lung base"],
        "clinical_significance": "Multiple etiologies including heart failure, infection, malignancy, or inflammatory conditions",
        "action_steps": ["Perform thoracentesis for diagnostic sampling", "Analyze pleural fluid", "Treat underlying cause"],
        "citations": ["Light RW. Clinical practice. Pleural effusion. N Engl J Med. 2002;346(25):1971-1977"]
    },
    "Pleural Other": {
        "definition": "Pleural abnormalities other than effusion",
        "xray_findings": ["Pleural thickening or irregularity", "Pleural plaques", "Calcification along pleural surfaces"],
        "clinical_significance": "May indicate asbestos exposure, prior empyema, tuberculosis, or pleural malignancy",
        "action_steps": ["Obtain detailed occupational history", "CT chest for characterization", "Consider pleural biopsy if malignancy suspected"],
        "citations": ["Huggins JT, et al. Pleural disease. Lancet. 2017;390(10113):2662-2674"]
    },
    "Pneumonia": {
        "definition": "Infection of the lung parenchyma with inflammatory consolidation",
        "xray_findings": ["Airspace opacity with consolidation", "Air bronchograms commonly present", "Lobar, segmental, or patchy distribution"],
        "clinical_significance": "Common respiratory infection requiring prompt antibiotic therapy",
        "action_steps": ["Assess severity using CURB-65 or PSI score", "Obtain blood and sputum cultures", "Initiate empiric antibiotic therapy"],
        "citations": ["Metlay JP, et al. Diagnosis and Treatment of Adults with Community-acquired Pneumonia. Am J Respir Crit Care Med. 2019;200(7):e45-e67"]
    },
    "Pneumothorax": {
        "definition": "Presence of air in the pleural space causing partial or complete lung collapse",
        "xray_findings": ["Visceral pleural line visible", "Absence of lung markings peripheral to line", "Deep sulcus sign on supine films"],
        "clinical_significance": "May be spontaneous or traumatic, tension pneumothorax is life-threatening emergency",
        "action_steps": ["Assess hemodynamic stability immediately", "Measure size of pneumothorax", "Consider chest tube placement", "Immediate needle decompression if tension pneumothorax"],
        "citations": ["MacDuff A, et al. Management of spontaneous pneumothorax. Thorax. 2010;65 Suppl 2:ii18-31"]
    },
    "Support Devices": {
        "definition": "Medical devices visible on chest radiograph",
        "xray_findings": ["Endotracheal or tracheostomy tube", "Central venous catheters", "Nasogastric tubes", "Chest tubes, pacemakers"],
        "clinical_significance": "Important to verify appropriate positioning and absence of complications",
        "action_steps": ["Verify endotracheal tube position 2-4 cm above carina", "Confirm central line tip in lower SVC", "Check for pneumothorax after device placement"],
        "citations": ["Godwin JD, et al. Pitfalls in ICU chest radiograph evaluation. J Thorac Imaging. 1995;10(4):247-254"]
    }
}

def get_pathology_info(pathology_name):
    """Retrieve medical knowledge for a specific pathology"""
    # Map variations to standard names
    name_mapping = {
        "Infiltration": "Lung Opacity",
        "Effusion": "Pleural Effusion",
        "Pleural_Thickening": "Pleural Other",
        "Nodule": "Lung Lesion",
        "Mass": "Lung Lesion",
        "Hernia": "Enlarged Cardiomediastinum"
    }
    lookup_name = name_mapping.get(pathology_name, pathology_name)
    return MEDICAL_KNOWLEDGE.get(lookup_name, None)

# ==================== RAG REPORT GENERATION ====================
class PredictionResult(BaseModel):
    disease: str
    confidence: float
    severity: str
    description: str
    critical: Optional[bool] = False

class ReportRequest(BaseModel):
    patient_name: str
    patient_id: str
    age: int
    gender: str
    predictions: List[PredictionResult]

class ReportResponse(BaseModel):
    report_text: str
    citations: List[str]
    findings_count: int
    timestamp: str

def generate_medical_report(patient_data, ml_predictions, top_n=3):
    """Generate a clean, doctor-style medical report"""
    sorted_predictions = sorted(ml_predictions, key=lambda x: x['confidence'], reverse=True)
    top_predictions = sorted_predictions[:top_n]
    
    report_sections = []
    all_citations = []
    
    # Header
    header = f"""RADIOLOGY REPORT - CHEST X-RAY

Patient Name: {patient_data['name']}
Patient ID: {patient_data['patient_id']}
Age: {patient_data['age']} years
Gender: {patient_data['gender']}
Examination Date: {datetime.now().strftime('%B %d, %Y')}
Examination Type: Chest Radiograph (PA/Lateral)

"""
    report_sections.append(header)
    
    # Clinical Findings
    findings_section = "FINDINGS:\n\n"
    
    if not top_predictions or all(p['confidence'] < 0.3 for p in top_predictions):
        findings_section += "The chest radiograph demonstrates clear lung fields bilaterally with no acute cardiopulmonary abnormality. "
        findings_section += "Cardiac silhouette is within normal limits. Mediastinal contours are unremarkable.\n\n"
    else:
        for idx, pred in enumerate(top_predictions, 1):
            pathology = pred['disease']
            confidence = pred['confidence']
            severity = pred['severity']
            
            knowledge = get_pathology_info(pathology)
            
            if knowledge and confidence > 0.3:
                findings_section += f"{idx}. "
                primary_finding = knowledge['xray_findings'][0]
                findings_section += f"{primary_finding}. "
                findings_section += f"This is consistent with {pathology.lower()}. "
                
                if confidence > 0.7:
                    findings_section += "High confidence finding.\n\n"
                elif confidence > 0.5:
                    findings_section += "Moderate confidence finding.\n\n"
                else:
                    findings_section += "Low confidence finding, correlation with clinical symptoms recommended.\n\n"
                
                all_citations.extend(knowledge['citations'])
    
    report_sections.append(findings_section)
    
    # Impression
    impression_section = "IMPRESSION:\n\n"
    
    if not top_predictions or all(p['confidence'] < 0.3 for p in top_predictions):
        impression_section += "No acute cardiopulmonary disease.\n\n"
    else:
        significant_findings = [p for p in top_predictions if p['confidence'] > 0.3]
        
        for pred in significant_findings:
            pathology = pred['disease']
            knowledge = get_pathology_info(pathology)
            
            if knowledge:
                impression_section += f"- {pathology}: {knowledge['clinical_significance']}\n"
        
        impression_section += "\n"
    
    report_sections.append(impression_section)
    
    # Recommendations
    recommendations_section = "RECOMMENDED ACTIONS:\n\n"
    
    if not top_predictions or all(p['confidence'] < 0.3 for p in top_predictions):
        recommendations_section += "- No immediate action required\n"
        recommendations_section += "- Routine follow-up as clinically indicated\n\n"
    else:
        action_steps = set()
        
        for pred in top_predictions:
            if pred['confidence'] > 0.3:
                knowledge = get_pathology_info(pred['disease'])
                if knowledge:
                    for step in knowledge['action_steps'][:2]:
                        action_steps.add(step)
        
        for idx, step in enumerate(action_steps, 1):
            recommendations_section += f"{idx}. {step}\n"
        
        recommendations_section += "\n"
    
    report_sections.append(recommendations_section)
    
    # Footer
    footer = """---
Report generated by RAD-ETHIX AI-Assisted Diagnostic System
This report should be reviewed by a licensed radiologist before clinical use
AI Confidence scores and findings are supplementary to clinical judgment
"""
    report_sections.append(footer)
    
    final_report = "".join(report_sections)
    unique_citations = list(dict.fromkeys(all_citations))
    
    return {
        'report_text': final_report,
        'citations': unique_citations,
        'findings_count': len([p for p in top_predictions if p['confidence'] > 0.3]),
        'timestamp': datetime.now().isoformat()
    }

@app.post("/generate-report", response_model=ReportResponse)
async def generate_report(request: ReportRequest):
    """Generate medical report using RAG"""
    try:
        patient_data = {
            "name": request.patient_name,
            "patient_id": request.patient_id,
            "age": request.age,
            "gender": request.gender
        }
        
        ml_predictions = [
            {
                "disease": p.disease,
                "confidence": p.confidence,
                "severity": p.severity
            }
            for p in request.predictions
        ]
        
        report_data = generate_medical_report(patient_data, ml_predictions)
        return report_data
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/pathologies")
async def list_pathologies():
    """Get list of all supported pathologies"""
    return {"pathologies": list(MEDICAL_KNOWLEDGE.keys())}

# ==================== EXISTING ML CODE ====================
POSITIVE_THRESHOLD = 0.3
HIGH_CONFIDENCE_THRESHOLD = 0.7
DOCTOR_REVIEW_THRESHOLD = 0.6

model = None
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

DISEASE_DESCRIPTIONS = {
    'Atelectasis': 'Collapse or closure of lung tissue resulting in reduced gas exchange',
    'Consolidation': 'Areas of lung filled with liquid instead of air, often indicating pneumonia',
    'Infiltration': 'Abnormal substance in lung tissue, may indicate infection or inflammation',
    'Pneumothorax': 'Collapsed lung due to air leak - requires immediate medical attention',
    'Edema': 'Fluid accumulation in lung tissue, may indicate heart failure',
    'Emphysema': 'Lung condition causing shortness of breath due to damaged air sacs',
    'Fibrosis': 'Lung scarring that makes breathing difficult',
    'Effusion': 'Abnormal accumulation of fluid around the lungs',
    'Pneumonia': 'Lung infection causing inflammation - may need antibiotic treatment',
    'Pleural_Thickening': 'Scarring of the lining around the lungs',
    'Cardiomegaly': 'Enlarged heart, may indicate underlying heart disease',
    'Nodule': 'Small spots in lungs that need follow-up evaluation',
    'Mass': 'Larger abnormal growth requiring immediate medical evaluation',
    'Hernia': 'Protrusion of organs visible on chest X-ray',
    'Lung Lesion': 'Abnormal tissue in lungs requiring medical assessment',
    'Fracture': 'Bone break visible on chest X-ray',
    'Lung Opacity': 'Cloudy areas in lungs that may indicate disease',
    'Enlarged Cardiomediastinum': 'Enlargement of heart and surrounding structures'
}

class TorchXRayVisionGradCAM:
    """Grad-CAM implementation for TorchXRayVision models"""
    def __init__(self, model):
        self.model = model
        self.gradients = None
        self.activations = None
        self.hook_layers()

    def hook_layers(self):
        def forward_hook(module, input, output):
            self.activations = output
        def backward_hook(module, grad_input, grad_output):
            self.gradients = grad_output[0]
        if hasattr(self.model, 'features') and hasattr(self.model.features, 'norm5'):
            target_layer = self.model.features.norm5
        elif hasattr(self.model, 'densenet121') and hasattr(self.model.densenet121.features, 'norm5'):
            target_layer = self.model.densenet121.features.norm5
        else:
            target_layer = list(self.model.modules())[-3]
        target_layer.register_forward_hook(forward_hook)
        target_layer.register_backward_hook(backward_hook)

    def generate_cam(self, input_tensor, class_idx):
        self.model.eval()
        output = self.model(input_tensor)
        self.model.zero_grad()
        class_score = output[0, class_idx]
        class_score.backward(retain_graph=True)
        if self.gradients is None or self.activations is None:
            return np.zeros((224, 224))
        weights = torch.mean(self.gradients, dim=[2, 3], keepdim=True)
        cam = torch.sum(weights * self.activations, dim=1).squeeze(0)
        cam = F.relu(cam)
        cam = cam.detach().cpu().numpy()
        if cam.max() > 0:
            cam = cam / cam.max()
        return cam

def create_heatmap_overlay(original_image, heatmap, alpha=0.4):
    """Create heatmap overlay on original image"""
    h, w = original_image.shape[:2]
    heatmap_resized = cv2.resize(heatmap, (w, h))
    heatmap_colored = cv2.applyColorMap(
        (heatmap_resized * 255).astype(np.uint8), 
        cv2.COLORMAP_JET
    )
    overlay = cv2.addWeighted(original_image, 1-alpha, heatmap_colored, alpha, 0)
    return overlay

def preprocess_xray_image(image_bytes):
    pil_image = Image.open(io.BytesIO(image_bytes)).convert('RGB')
    img = np.array(pil_image)
    if len(img.shape) > 2:
        img = img[:, :, 0]
    img = xrv.datasets.normalize(img, 255)
    img = img[None, :, :]
    transform = torchvision.transforms.Compose([
        xrv.datasets.XRayCenterCrop()
    ])
    img = transform(img)
    return img, np.array(pil_image)

@app.on_event("startup")
async def startup_event():
    global model
    logger.info("üöÄ Starting RAD-ETHIX with TorchXRayVision...")
    logger.info(f"Device: {device}")
    try:
        logger.info("üì¶ Loading DenseNet121 trained on CheXpert...")
        model = xrv.models.get_model("densenet121-res224-chex")
        model.to(device)
        model.eval()
        logger.info("‚úÖ TorchXRayVision model loaded successfully!")
        logger.info(f"Model supports {len(xrv.datasets.default_pathologies)} pathologies")
    except Exception as e:
        logger.error(f"‚ùå Failed to load model: {e}")
        raise e

@app.get("/", response_class=HTMLResponse)
async def root():
    html_content = """
    <!DOCTYPE html>
    <html>
    <head>
        <title>RAD-ETHIX API</title>
        <meta charset="UTF-8">
        <style>
            body { font-family: Arial, sans-serif; margin: 40px; background: #f5f5f5; }
            .container { max-width: 800px; margin: 0 auto; background: white; padding: 30px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
            h1 { color: #2c3e50; border-bottom: 3px solid #3498db; padding-bottom: 10px; }
            .status { background: #d4edda; border: 1px solid #c3e6cb; color: #155724; padding: 15px; border-radius: 5px; margin: 20px 0; }
        </style>
    </head>
    <body>
        <div class="container">
            <h1>üè• RAD-ETHIX API v2.0</h1>
            <div class="status">
                ‚úÖ <strong>API is running with RAG + Authentication!</strong><br>
                ü§ñ TorchXRayVision DenseNet121 (CheXpert-trained)<br>
                üîê Auth Endpoints: /auth/login, /auth/signup<br>
                üìÑ RAG Report: /generate-report
            </div>
        </div>
    </body>
    </html>
    """
    return HTMLResponse(content=html_content)

@app.get("/health")
async def health_check():
    return {
        "status": "healthy" if model else "degraded",
        "model_loaded": model is not None,
        "device": str(device),
        "torch_version": torch.__version__,
        "features": ["Authentication", "RAG Reports", "ML Prediction", "Grad-CAM"],
        "pathologies": xrv.datasets.default_pathologies if model else []
    }

@app.get("/diseases")
async def get_diseases():
    diseases = []
    for disease in xrv.datasets.default_pathologies:
        diseases.append({
            "name": disease,
            "description": DISEASE_DESCRIPTIONS.get(disease, f"Medical condition: {disease}")
        })
    return {
        "diseases": diseases,
        "total_count": len(diseases),
        "source": "CheXpert Dataset via TorchXRayVision"
    }

@app.post("/predict")
async def predict_chest_xray(file: UploadFile = File(...)):
    if not model:
        raise HTTPException(status_code=503, detail="Model not loaded")
    if not file.content_type.startswith('image/'):
        raise HTTPException(status_code=400, detail="Please upload an image file")
    try:
        logger.info(f"üî¨ Analyzing X-ray: {file.filename}")
        contents = await file.read()
        processed_img, original_img = preprocess_xray_image(contents)
        img_tensor = torch.from_numpy(processed_img).unsqueeze(0).to(device)
        img_tensor.requires_grad_(True)
        with torch.no_grad():
            predictions = model(img_tensor).cpu().numpy()[0]
        probabilities = torch.sigmoid(torch.from_numpy(predictions)).numpy()
        grad_cam = TorchXRayVisionGradCAM(model)
        findings = []
        for i, disease in enumerate(xrv.datasets.default_pathologies):
            confidence = float(probabilities[i])
            if confidence > POSITIVE_THRESHOLD:
                if disease in ['Pneumothorax', 'Mass', 'Pneumonia']:
                    if confidence >= 0.5:
                        severity = "Critical"
                    elif confidence >= 0.35:
                        severity = "High"
                    else:
                        severity = "Moderate"
                else:
                    if confidence >= HIGH_CONFIDENCE_THRESHOLD:
                        severity = "High"
                    elif confidence >= 0.5:
                        severity = "Moderate"
                    else:
                        severity = "Low"
                finding = {
                    "disease": disease,
                    "confidence": confidence,
                    "severity": severity,
                    "description": DISEASE_DESCRIPTIONS.get(disease, f"Medical condition: {disease}"),
                    "critical": (disease == "Pneumonia" and severity == "Critical")
                }
                findings.append(finding)
        sorted_findings = sorted(findings, key=lambda x: x["confidence"], reverse=True)
        result_findings = sorted_findings[:3]
        pneumonia_critical = next(
            (f for f in findings if f["disease"] == "Pneumonia" and f["severity"] == "Critical"),
            None
        )
        if pneumonia_critical and all(f["disease"] != "Pneumonia" for f in result_findings):
            result_findings.append(pneumonia_critical)
        combined_heatmap_b64 = None
        if result_findings:
            try:
                max_idx = np.argmax(probabilities)
                combined_cam = grad_cam.generate_cam(img_tensor, max_idx)
                img_resized = cv2.resize(original_img, (224, 224))
                if len(img_resized.shape) == 3:
                    img_gray = cv2.cvtColor(img_resized, cv2.COLOR_RGB2GRAY)
                    img_overlay = cv2.cvtColor(img_gray, cv2.COLOR_GRAY2RGB)
                else:
                    img_overlay = cv2.cvtColor(img_resized, cv2.COLOR_GRAY2RGB)
                combined_overlay = create_heatmap_overlay(img_overlay, combined_cam)
                _, buffer = cv2.imencode('.png', combined_overlay)
                combined_heatmap_b64 = base64.b64encode(buffer).decode()
            except Exception as e:
                logger.warning(f"Failed to generate combined heatmap: {e}")
        overall_confidence = float(np.max(probabilities))
        needs_review = overall_confidence < DOCTOR_REVIEW_THRESHOLD or len(result_findings) > 2
        ai_report = generate_clinical_report(result_findings, overall_confidence)
        patient_report = generate_patient_report(result_findings)
        response = {
            "status": "success",
            "timestamp": str(pd.Timestamp.now()),
            "findings": result_findings,
            "confidence_metrics": {
                "overall_confidence": overall_confidence,
                "average_confidence": float(np.mean([f["confidence"] for f in result_findings])) if result_findings else 0.0,
                "uncertainty": 1.0 - overall_confidence
            },
            "combined_heatmap": combined_heatmap_b64,
            "ai_report": ai_report,
            "patient_report": patient_report,
            "needs_doctor_review": needs_review,
            "review_reason": "Low confidence" if overall_confidence < DOCTOR_REVIEW_THRESHOLD else "Multiple findings" if len(result_findings) > 2 else "Standard review",
            "model_info": {
                "name": "TorchXRayVision DenseNet121",
                "training_dataset": "CheXpert",
                "paper": "https://arxiv.org/abs/2111.00595",
                "pathologies_supported": len(xrv.datasets.default_pathologies)
            },
            "metadata": {
                "filename": file.filename,
                "model_version": "TorchXRayVision-v2.0",
                "device": str(device),
                "findings_count": len(result_findings),
                "detection_threshold": POSITIVE_THRESHOLD
            }
        }
        logger.info(f"‚úÖ Analysis complete: {len(result_findings)} findings detected")
        return response
    except Exception as e:
        logger.error(f"‚ùå Prediction failed: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

def generate_clinical_report(findings, confidence):
    report = "CHEST X-RAY AI ANALYSIS REPORT\n"
    report += "=" * 50 + "\n\n"
    report += f"MODEL: TorchXRayVision DenseNet121 (CheXpert-trained)\n"
    report += f"ANALYSIS DATE: {pd.Timestamp.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n"
    if not findings:
        report += "FINDINGS: No significant pathological findings detected\n"
        report += "RECOMMENDATION: Normal chest radiograph\n"
    else:
        report += f"FINDINGS: {len(findings)} pathological conditions detected\n\n"
        for i, finding in enumerate(findings, 1):
            report += f"{i}. {finding['disease'].upper()}\n"
            report += f"   ‚Ä¢ Confidence: {finding['confidence']:.1%}\n"
            report += f"   ‚Ä¢ Severity: {finding['severity']}\n"
            report += f"   ‚Ä¢ Description: {finding['description']}\n\n"
    report += f"OVERALL CONFIDENCE: {confidence:.1%}\n"
    report += "NOTE: This analysis uses a validated model trained on CheXpert dataset\n"
    report += "Clinical correlation and physician review recommended\n"
    return report

def generate_patient_report(findings):
    report = "Your Chest X-Ray Results\n"
    report += "=" * 30 + "\n\n"
    if not findings:
        report += "‚úÖ GOOD NEWS: No concerning findings detected\n\n"
        report += "The AI analysis did not identify signs of disease in your chest X-ray.\n"
    else:
        report += f"üìã SUMMARY: {len(findings)} findings detected\n\n"
        report += "The AI has identified some areas that may need medical attention:\n\n"
        for i, finding in enumerate(findings, 1):
            report += f"{i}. {finding['disease']}\n"
            report += f"   ‚Ä¢ AI Confidence: {finding['confidence']:.0%}\n"
            report += f"   ‚Ä¢ What it means: {finding['description']}\n"
            if finding.get('critical'):
                report += f"   ‚Ä¢ ‚ö†Ô∏è  IMPORTANT: Needs prompt medical attention\n"
            report += "\n"
    report += "NEXT STEPS:\n"
    report += "‚Ä¢ Schedule appointment with your doctor\n"
    report += "‚Ä¢ Discuss these results and your symptoms\n"
    report += "‚Ä¢ Follow medical advice for treatment\n\n"
    report += "NOTE: This AI uses a medical-grade model trained on real hospital data\n"
    report += "Only qualified doctors can provide final diagnosis and treatment\n"
    return report

if __name__ == "__main__":
    import uvicorn
    logger.info("üöÄ Starting RAD-ETHIX API server...")
    uvicorn.run(
        "main:app", 
        host="127.0.0.1", 
        port=8000, 
        reload=True,
        log_level="info"
    )